### GMP 调度流程


```
每个 P有个局部队列，局部队列保存待执行的 goroutine(流程2)，当 M绑定的 P的的局部队列已经满了之后就
会把 goroutine 放到全局队列(流程2-1)
每个 P和一个 M绑定，M是真正的执行 P中 goroutine 的实体(流程3)，M 从绑定的 P中的局部队列获取 G来
执行
当 M绑定的 P的局部队列为空时，M会从全局队列获取到本地队列来执行
```
G(流程3.1)，当从全局队列中没有获取到可执行的 G时候，M会从其他 P 的局部队列中偷取 G来执行(流程3.2)，这
种从其他 P偷的方式称为 work stealing

```
当 G因系统调用(syscall)阻塞时会阻塞 M，此时 P会和 M解绑即 hand
```
off，并寻找新的 idle 的 M，若没有 idle 的 M就会新建一个 M(流程5.1)。

```
当 G因 channel 或者 network I/O 阻塞时，不会阻塞 M，M会寻找其他 runnable 的 G；当阻塞的 G恢复后
会重新进入 runnable 进入 P队列等待执行(流程5.3)
```
### GMP 中 work stealing 机制

#### 存到 P本地队列或者是全局队列。P此时去唤醒一个 M。P继续执行它的执行序。M寻找是否有空闲的 P，如果有则

将该 G对象移动到它本身。接下来 M执行一个调度循环(调用 G对象->执行->清理线程→继续找新的 Goroutine 执
行)。

### GMP 中 hand off 机制

#### 当本线程 M因为 G进行的系统调用阻塞时，线程释放绑定的 P，把 P转移给其他空闲的 M'执行。当发生上线文切换

时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器 M的栈保存在 G对象上，只需要
将 M所需要的寄存器(SP、PC等)保存到 G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以
做上下文切换了，在中断之前把现场保存起来。如果此时 G任务还没有执行完，M可以将任务重新丢到 P的任务队
列，等待下一次被调度执行。当再次被调度执行时，M通过访问 G的 vdsoSP、vdsoPC寄存器进行现场恢复(从上次
中断位置继续执行)。


### 协作式的抢占式调度

在1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，存在问题

```
某些 Goroutine 可以⻓时间占用线程，造成其它 Goroutine 的饥饿
垃圾回收需要暂停整个程序（Stop-the-world，STW），最⻓可能需要几分钟的时间，导致整个程序无法工
作。
```
### 基于信号的抢占式调度

在任何情况下，Go运行时并行执行（注意，不是并发）的 goroutines 数量是小于等于 P 的数量的。为了提高系统
的性能，P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的
M，由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点： GO 的调度器是迟钝的，它很可能什
么都没做，直到 M 阻塞了相当⻓时间以后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强
这个 P。通过 sysmon 监控实现的抢占式调度，最快在20us，最慢在10-20ms才会发现有一个 M 持有 P 并阻塞
了。操作系统在1ms 内可以完成很多次线程调度（一般情况1ms可以完成几十次线程调度），Go 发起 IO/syscall
的时候执行该 G 的 M 会阻塞然后被 OS调度走，P什么也不干，sysmon 最慢要10-20ms 才能发现这个阻塞，说不
定那时候阻塞已经结束了，宝贵的 P资源就这么被阻塞的 M浪费了。

### GMP 调度过程中存在哪些阻塞

```
I/O，select
block on syscall
channel
等待锁
runtime.Gosched()
```
### sysmon 有什么作用

sysmon 也叫监控线程，变动的周期性检查，好处

```
释放闲置超过 5 分钟的 span 物理内存；
如果超过 2 分钟没有垃圾回收，强制执行；
将⻓时间未处理的 netpoll 添加到全局队列；
向⻓时间运行的 G 任务发出抢占调度(超过10ms的 g，会进行 retake)；
收回因 syscall ⻓时间阻塞的 P；
```
### golang面试题：怎么避免内存逃逸？

https://mp.weixin.qq.com/s/VzRTHz1JaDUvNRVB_yJa1A


### golang面试题：简单聊聊内存逃逸？

https://mp.weixin.qq.com/s/wJmztRMB1ZAAIItyMcS0tw

### 三色标记原理

#### 我们首先看一张图，大概就会对三色标记法有一个大致的了解：

#### 原理：

#### 首先把所有的对象都放到白色的集合中

#### 从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中

#### 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的

#### 对象放到黑色的集合中

#### 循环步骤 3 ，知道灰色集合中没有对象

#### 步骤 4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收

### 插入写屏障

golang 的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有 hook 的原因，所以栈中没有启用写屏障，
所以有 STW。golang 的解决方法是：只是需要在结束时启动 STW来重新扫描栈。这个自然就会导致整个进程的赋
值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。混合写屏障之后，就没有 STW。

### 删除写屏障

goalng 没有这一步，golang 的内存写屏障是由插入写屏障到混合写屏障过渡的。简单介绍一下，一个对象即使被
删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC中被清理掉。


### 写屏障

Go在进行三色标记的时候并没有 STW，也就是说，此时的对象还是可以进行修改。

那么我们考虑一下，下面的情况。

#### 我们在进行三色标记中扫描灰色集合中，扫描到了对象 A，并标记了对象 A的所有引用，这时候，开始扫描对象 D

的引用，而此时，另一个 goroutine 修改了 D->E的引用，变成了如下图所示


#### 这样会不会导致 E对象就扫描不到了，而被误认为为白色对象，也就是垃圾写屏障就是为了解决这样的问题，引入

#### 写屏障后，在上述步骤后， E会被认为是存活的，即使后面 E被 A对象抛弃，E会被在下一轮的 GC中进行回收，这

#### 一轮 GC中是不会对对象 E进行回收的。

### 混合写屏障

#### 混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；

#### 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC期间，任何在栈上创建的新对象，均为黑

#### 色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；

#### 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；

```
混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工
作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。
```
### GC 触发时机

**主动触发** ：调用 runtime.GC

**被动触发** ：

使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC
时，强制触发 GC。

使用步调（Pacing）算法，其核心思想是控制内存增⻓的比例。如 Go 的 GC 是一种比例 GC,下一次 GC 结束时的
堆大小和上一次 GC 存活堆大小成比例.由 GOGC 控制,默认100,即 2 倍的关系,200 就是 3 倍,

当 Go新创建的对象所占用的内存大小，除以上次 GC结束后保留下来的对象占用内存大小。


### Go 语言中 GC 的流程是什么？

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：阶段说明赋值器状态 GCMark标记准备阶段，为并发
标记做准备工作，启动写屏障 STWGCMark扫描标记阶段，与赋值器并发执行，写屏障开启并发
GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障 STWGCoff内存清扫阶段，将需
要回收的内存归还到堆中，写屏障关闭并发 GCoff内存归还阶段，将过多的内存归还给操作系统，写屏障关闭并
发。

### GC 如何调优

通过 go tool pprof 和 go tool trace 等工具

```
控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的
拷⻉。
需要时，增大 GOGC 的值，降低 GC 的运行频率。
```
### Go语言的栈空间管理是怎么样的?

Go语言的运行环境（runtime）会在goroutine需要的时候动态地分配栈空间，而不是给每个goroutine分配固定大
小的内存空间。这样就避免了需要程序员来决定栈的大小。

分块式的栈是最初Go语言组织栈的方式。当创建一个goroutine的时候，它会分配一个8KB的内存空间来给
goroutine的栈使用。我们可能会考虑当这8KB的栈空间被用完的时候该怎么办?

为了处理这种情况，每个Go函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空
间。如果是的话，它会调用morestack函数。morestack函数分配一块新的内存作为栈空间，并且在这块栈空间
的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的
函数。这个过程叫做栈分裂（stack split）。

在新分配的栈底部，还插入了一个叫做lessstack的函数指针。这个函数还没有被调用。这样设置是为了从刚才
造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到lessstack。lessstack函
数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的
栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了。

分块式的栈让我们能够按照需求来扩展和收缩栈的大小。 Go开发者不需要花精力去估计goroutine会用到多大的
栈。创建一个新的goroutine的开销也不大。当 Go开发者不知道栈会扩展到多少大时，它也能很好的处理这种情
况。

这一直是之前Go语言管理栈的的方法。但这个方法有一个问题。缩减栈空间是一个开销相对较大的操作。如果在
一个循环里有栈分裂，那么它的开销就变得不可忽略了。一个函数会扩展，然后分裂栈。当它返回的时候又会释放
之前分配的内存块。如果这些都发生在一个循环里的话，代价是相当大的。 这就是所谓的热分裂问题（hot split
problem）。它是Go语言开发者选择新的栈管理方法的主要原因。新的方法叫做栈复制法（stack copying）。

栈复制法一开始和分块式的栈很像。当goroutine运行并用完栈空间的时候，与之前的方法一样，栈溢出检查会被
触发。但是，不像之前的方法那样分配一个新的内存块并链接到老的栈内存块，新的方法会分配一个两倍大的内存
块并把老的内存块内容复制到新的内存块里。这样做意味着当栈缩减回之前大小时，我们不需要做任何事情。栈的
缩减没有任何代价。而且，当栈再次扩展时，运行环境也不需要再做任何事。它可以重用之前分配的空间。


#### 栈的复制听起来很容易，但实际操作并非那么简单。存储在栈上的变量的地址可能已经被使用到。也就是说程序使

#### 用到了一些指向栈的指针。当移动栈的时候，所有指向栈里内容的指针都会变得无效。然而，指向栈内容的指针自

#### 身也必定是保存在栈上的。这是为了保证内存安全的必要条件。否则一个程序就有可能访问一段已经无效的栈空间

#### 了。

#### 因为垃圾回收的需要，我们必须知道栈的哪些部分是被用作指针了。当我们移动栈的时候，我们可以更新栈里的指

#### 针让它们指向新的地址。所有相关的指针都会被更新。我们使用了垃圾回收的信息来复制栈，但并不是任何使用栈

#### 的函数都有这些信息。因为很大一部分运行环境是用C语言写的，很多被调用的运行环境里的函数并没有指针的信

#### 息，所以也就不能够被复制了。当遇到这种情况时，我们只能退回到分块式的栈并支付相应的开销。

这也是为什么现在运行环境的开发者正在用Go语言重写运行环境的大部分代码。无法用Go语言重写的部分（比如
调度器的核心代码和垃圾回收器）会在特殊的栈上运行。这个特殊栈的大小由运行环境的开发者设置。

这些改变除了使栈复制成为可能，它也允许我们在将来实现并行垃圾回收。

另外一种不同的栈处理方式就是在虚拟内存中分配大内存段。由于物理内存只是在真正使用时才会被分配，因此看
起来好似你可以分配一个大内存段并让操 作系统处理它。下面是这种方法的一些问题

首先， 32 位系统只能支持4G字节虚拟内存，并且应用只能用到其中的3G空间。由于同时运行百万goroutines的情
况并不少⻅，因此你很可 能用光虚拟内存，即便我们假设每个goroutine的stack只有8K。

第二，然而我们可以在 64 位系统中分配大内存，它依赖于过量内存使用。所谓过量使用是指当你分配的内存大小超
出物理内存大小时，依赖操作系统保证 在需要时能够分配出物理内存。然而，允许过量使用可能会导致一些⻛险。
由于一些进程分配了超出机器物理内存大小的内存，如果这些进程使用更多内存 时，操作系统将不得不为它们补充
分配内存。这会导致操作系统将一些内存段放入磁盘缓存，这常常会增加不可预测的处理延迟。正是考虑到这个原
因，一 些新系统关闭了对过量使用的支持。

### Goroutine和Channel的作用分别是什么?

进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程
里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。

那协程又是什么呢，以及与线程的差异性??

协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户
控制的。

最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用
的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。

Go中的goroutinue就是协程,可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理
器上跑（可以把宿主语言想象成单线程的就好了）。 然而,多个goroutine之间的通信是通过channel，而协程的通
信是通过yield和resume()操作。

goroutine非常简单，只需要在函数的调用前面加关键字go即可，例如:

我们也可以启动 5 个goroutines分别打印索引。

```
go elegance()
```

在分析goroutine执行的随机性和并发性，启动了 5 个goroutine，再加上main函数的主goroutine，总共有 6 个
goroutines。由于goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打
印了。

在Golang中channel则是goroutinues之间进行通信的渠道。

可以把channel形象比喻为工厂里的传送带,一头的生产者goroutine往传输带放东⻄,另一头的消费者goroutinue则
从输送带取东⻄。channel实际上是一个有类型的消息队列,遵循先进先出的特点。

1. channel的操作符号

ch <- data 表示data被发送给channel ch；

data <- ch 表示从channel ch取一个值，然后赋给data。

1. 阻塞式channel

channel默认是没有缓冲区的，也就是说，通信是阻塞的。send操作必须等到有消费者accept才算完成。

应用示例:

在函数pump()里的channel在接受到第一个元素后就被阻塞了，直到主goroutinue取走了数据。最终channel阻塞
在接受第二个元素，程序只打印 1 。

没有缓冲(buffer)的channel只能容纳一个元素，而带有缓冲(buffer)channel则可以非阻塞容纳N个元素。发送数据
到缓冲(buffer) channel不会被阻塞，除非channel已满；同样的，从缓冲(buffer) channel取数据也不会被阻塞，
除非channel空了。

```
func main() {
for i:=1;i<5;i++ {
go func(i int) {
fmt.Println(i)
}(i)
}
// 停歇5s，保证打印全部结束
time.Sleep(5*time.Second)
}
```
```
func main() {
ch1 := make(chan int)
go pump(ch1) // pump hangs
fmt.Println(<-ch1) // prints only 1
}
```
```
func pump(ch chan int) {
for i:= 1; ; i++ {
ch <- i
}
}
```

### 怎么查看Goroutine的数量?

GOMAXPROCS中控制的是未被阻塞的所有Goroutine,可以被Multiplex到多少个线程上运行,通过GOMAXPROCS可
以查看Goroutine的数量。