
## 与其他语言相比，使用 Go 有什么好处？

```
与其他作为学术实验开始的语言不同，Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的生活
更轻松。
Golang 针对并发进行了优化，并且在规模上运行良好。
由于单一的标准代码格式，Golang 通常被认为比其他语言更具可读性。
自动垃圾收集明显比 Java 或 Python 更有效，因为它与程序同时执行。
```
## Golang 使用什么数据类型？

Golang 使用以下类型：

```
Method
Boolean
Numeric
String
Array
Slice
Struct
Pointer
Function
Interface
Map
Channel
```

## 关于整型切片的初始化，下面正确的是？

A. s := make([]int)

B. s := make([]int, 0)

C. s := make([]int, 5, 10)

D. s := []int{1, 2, 3, 4, 5}

答案

```
B C D
```
## 下列代码是否会触发异常？
```go
func Test59(t *testing.T) {
 runtime.GOMAXPROCS(1)
 intChan := make(chan int, 1)
 stringChan := make(chan string, 1)
 intChan <- 1
 stringChan <- "hello"
 select {
 case value := <-intChan:
 fmt.Println(value)
 case value := <-stringChan:
 panic(value)
 }
}
```
### 答案

```
不一定，当两个chan同时有值时，select 会随机选择一个可用通道做收发操作
```
## 关于channel的特性，下面说法正确的是？

A. 给一个 nil channel 发送数据，造成永远阻塞

B. 从一个 nil channel 接收数据，造成永远阻塞

C. 给一个已经关闭的 channel 发送数据，引起 panic

D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值

答案

```
func Test59(t *testing.T) {
runtime.GOMAXPROCS( 1 )
intChan := make(chan int, 1 )
stringChan := make(chan string, 1 )
intChan <- 1
stringChan <- "hello"
select {
case value := <-intChan:
fmt.Println(value)
case value := <-stringChan:
panic(value)
}
}
```

### A B C D

## 下列代码有什么问题？

### 答案

```
Go语言中，常量无法寻址, 是不能进行取指针操作的
```
## 下列代码输出什么？

### 答案

### 012

```
range 一个返回值时，这个值是下标，两个值时，第一个是下标，第二个是值，当 x 为 map时，第一个是
key，第二个是value
```
## 关于无缓冲和有冲突的channel，下面说法正确的是？

A. 无缓冲的channel是默认的缓冲为 1 的channel；

B. 无缓冲的channel和有缓冲的channel都是同步的；

C. 无缓冲的channel和有缓冲的channel都是非同步的；

D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；

答案

```
D
```
```
const i = 100
var j = 123
```
```
func main() {
fmt.Println(&j, j)
fmt.Println(&i, i)
}
```
```
func Test62(t *testing.T) {
x := []string{"a", "b", "c"}
for v := range x {
fmt.Print(v)
}
}
```

## 下列代码输出什么？

### 答案

```
non-empty interface
接口除了有静态类型，还有动态类型和动态值，
当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。
这里的 x 的动态类型是 *int，所以 x 不为 nil
```
## 关于select机制，下面说法正确的是?

A. select机制用来处理异步IO问题；

B. select机制最大的一条限制就是每个case语句里必须是一个IO操作；

C. golang在语言级别支持select关键字；

D. select关键字的用法与switch语句非常类似，后面要带判断条件；

答案

```
A B C
```
## Go 程序中的包是什么？

包(pkg)是 Go 工作区中包含 Go 源文件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每
个 Go 源文件都属于一个包，该包在文件顶部使用以下命令声明：

### 您可以使用以下方法导入和导出包以重用导出的函数或类型：

```
func Foo(x interface{}) {
if x == nil {
fmt.Println("empty interface")
return
}
fmt.Println("non-empty interface")
}
func Test64(t *testing.T) {
var x *int = nil
Foo(x)
}
```
```
package <packagename>
```
```
import <packagename>
```

Golang 的标准包是 fmt，其中包含格式化和打印功能，如 Println().

## 关于字符串拼接,下列正确的是?

A. str := 'abc' + '123'

B. str := "abc" + "123"

C. str ：= '123' + "abc"

D. fmt.Sprintf("abc%d", 123)

答案

```
B D 双引号用来表示字符串 string，其实质是一个 byte 类型的数组，单引号表示 rune 类型。
```
## 连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知

## 了。

https://mp.weixin.qq.com/s/sW4PD1MiaunURNDIU4BbQQ

## golang面试题：字符串转成byte数组，会发生内存拷⻉吗？

https://mp.weixin.qq.com/s/qmlPuGVISx8NYp2b9LrqnA

## golang面试题：翻转含有中文、数字、英文字母的字符串

https://mp.weixin.qq.com/s/ssinnUM22PHPWRug8EzAkg

## golang面试题：拷⻉大切片一定比小切片代价大吗？

https://mp.weixin.qq.com/s/8Dp2eCYzDdBbxAG5-jNevQ

## golang面试题：json包变量不加tag会怎么样？

https://mp.weixin.qq.com/s/bZlKV_BWSqc-qCa4DrsCbg


## golang面试题：reflect（反射包）如何获取字段tag？为什么json包不能

## 导出私有变量的tag？

https://mp.weixin.qq.com/s/P7TEx2mInwEktXTEE6JDWQ

## 昨天那个在for循环里append元素的同事，今天还在么？

https://mp.weixin.qq.com/s/SHxcspmiKyPwPBbhfVxsGA

## go struct能不能比较

```
相同struct类型的可以比较
不同struct类型的不可以比较,编译都不过，类型不匹配
```
```
package main
import "fmt"
func main() {
type A struct {
a int
}
type B struct {
a int
}
a := A{1}
//b := A{1}
b := B{1}
if a == b {
fmt.Println("a == b")
}else{
fmt.Println("a != b")
}
}
// output
// command-line-arguments [command-line-arguments.test]
// ./.go:14:7: invalid operation: a == b (mismatched types A and B)
```

## Go 支持什么形式的类型转换？将整数转换为浮点数。

Go 支持显式类型转换以满足其严格的类型要求。

## Log包线程安全吗？

Golang的标准库提供了log的机制，但是该模块的功能较为简单（看似简单，其实他有他的设计思路）。在输出的
位置做了线程安全的保护。

## Goroutine和线程的区别?

从调度上看，goroutine的调度开销远远小于线程调度开销。

OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂
停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存
中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程
的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。

Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程
（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构
来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。

从栈空间上，goroutine的栈空间更加动态灵活。

每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者
临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比
goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不
罕⻅（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到
1GB。

goroutine没有一个特定的标识。

在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以
让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个
map存储和获取值，不受其他线程干扰。

goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的
超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。

```
i := 55 //int
```
```
j := 67.8 //float64
```
```
sum := i + int(j)//j is converted to int
```

## 下列哪一行会panic?

### 答案

```
_ = y == y 会发生panic, 因为两个比较值的动态类型为同一个不可比较类型
```
## 下列哪行代码会panic?

### 答案

```
_ = x[6:] 这一行会发生panic, 截取符号 [i:j]，
如果 j 省略，默认是原切片或者数组的⻓度，x 的⻓度是 2 ，小于起始下标 6 ，所以 panic
```
## 什么是 Goroutine？你如何停止它？

一个 Goroutine 是一个函数或方法执行同时旁边其他任何够程采用了特殊的 Goroutine 线程。Goroutine 线程比
标准线程更轻量级，大多数 Golang 程序同时使用数千个 g、Goroutine。

要创建 Goroutine，请 go 在函数声明之前添加关键字。

您可以通过向 Goroutine 发送一个信号通道来停止它。Goroutines 只能在被告知检查时响应信号，因此您需要在
逻辑位置（例如 for 循环顶部）包含检查。

```
func Test76(t *testing.T) {
var x interface{}
var y interface{} = []int{ 3 , 5 }
_ = x == x
_ = x == y
_ = y == y
}
```
```
func Test77(t *testing.T) {
x := make([]int, 2 , 10 )
_ = x[ 6 : 10 ]
_ = x[ 6 :]
_ = x[ 2 :]
}
```
```
go f(x, y, z)
```
```
package main
```
```
func main(){
```
```
quit := make(chan bool) go func(){
```

## Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？

Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

## 无缓冲 Chan 的发送和接收是否同步?

```
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。
```
## 关于switch语句，下面说法正确的有?

### A. 条件表达式必须为常量或者整数；

B. 单个case中，可以出现多个结果选项；

C. 需要用break来明确退出一个case；

D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；

```
for {
```
```
select {
```
```
case <-quit:
```
```
return default:
```
```
//...
```
```
}
```
```
}
```
```
}()
```
```
//...
```
```
quit <- true
```
```
}
```
```
ch := make(chan int) 无缓冲的channel由于没有缓冲发送和接收需要同步.
ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步.
```

### 答案

### B D

## 下列Add函数定义正确的是？

### 答案

### A C

## 关于 bool 变量 b 的赋值，下面错误的用法是？

A. b = true

B. b = 1

C. b = bool(1)

D. b = (1 == 2)

```
func Test54(t *testing.T) {
var a Integer = 1
var b Integer = 2
var i interface{} = &a
sum := i.(*Integer).Add(b)
fmt.Println(sum)
}
A.
type Integer int
func (a Integer) Add(b Integer) Integer {
return a + b
}
```
```
B.
type Integer int
func (a Integer) Add(b *Integer) Integer {
return a + *b
}
```
```
C.
type Integer int
func (a *Integer) Add(b Integer) Integer {
return *a + b
}
```
```
D.
type Integer int
func (a *Integer) Add(b *Integer) Integer {
return *a + *b
}
```

### 答案

### B C

## 关于变量的自增和自减操作，下面语句正确的是？

### A.

### B.

### C.

### D.

### 答案

### A D

```
go 里面没有 ++i 和 --i
```
## go语言的并发机制以及它所使用的CSP并发模型．

### CSP模型是上个世纪七十年代提出的,不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享

内存”。用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一
类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。

Golang中channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体
通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中
间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现
原理上其实类似一个阻塞的消息队列。

Goroutine 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户
态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：

```
i := 1
i++
```
```
i := 1
j = i++
```
```
i := 1
++i
```
```
i := 1
i--
```

### 用户空间 避免了内核态和用户态的切换导致的成本。

### 可以由语言和框架层进行调度。

### 更小的栈空间允许创建大量的实例。

Golang中的Goroutine的特性:

Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线
程，G对象（goroutine）.

正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时
候，会启动一个新的工作线程，以充分利用cpu资源。 所有有时候线程对象会比处理器对象多很多.

我们用如下图分别表示P、M、G:

G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信
息.

M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）.

P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设
置，默认为核心数.

在单核情况下，所有Goroutine运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个
上下文中只有一个Goroutine，其他Goroutine在runqueue中等待。

一个Goroutine运行完自己的时间片后，让出上下文，自己回到runqueue中（如下图所示）。

当正在运行的G0阻塞的时候（可以需要IO），会再创建一个线程（M1），P转到新的线程中去运行。


当M0返回时，它会尝试从其他线程中“偷”一个上下文过来，如果没有偷到，会把Goroutine放到Global runqueue
中去，然后把自己放入线程缓存中。 上下文会定时检查Global runqueue。

Golang是为并发而生的语言，Go语言是为数不多的在语言层面实现并发的语言；也正是Go语言的并发特性，吸引
了全球无数的开发者。

Golang的CSP并发模型，是通过Goroutine和Channel来实现的。

Goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。
Channel是Go语言中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”
管道“，有点类似于Linux中的管道。

通信机制channel也很方便，传数据用channel <- data，取数据用<-channel。

在通信过程中，传数据channel <- data和取数据<-channel必然会成对出现，因为这边传，那边取，两个
goroutine之间才会实现通信。

而且不管传还是取，必阻塞，直到另外的goroutine传或者取为止。

## Golang 中常用的并发模型？

Golang 中常用的并发模型有三种:

```
通过channel通知实现并发控制
```
无缓冲的通道指的是通道的大小为 0 ，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送
goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。


从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准
备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同
步通道。

当主 goroutine 运行到 <-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有
值。 这样就可以简单实现并发控制

```
通过sync包中的WaitGroup实现并发控制
```
Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个
时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完
成。在WaitGroup里主要有三个方法:

```
Add, 可以添加或减少 goroutine的数量.
Done, 相当于Add(-1).
Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
```
在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个
goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。

```
func main() {
ch := make(chan struct{})
go func() {
fmt.Println("start working")
time.Sleep(time.Second * 1)
ch <- struct{}{}
}()
```
```
<-ch
```
```
fmt.Println("finished")
}
```
```
func main(){
var wg sync.WaitGroup
var urls = []string{
"http://www.golang.org/",
"http://www.google.com/",
}
for _, url := range urls {
wg.Add(1)
go func(url string) {
defer wg.Done()
http.Get(url)
}(url)
}
wg.Wait()
}
```

在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup
第一次使用后，不能被拷⻉

应用示例:

### 运行:

它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷⻉传递到了 goroutine 中，导致只有 Add
操作，其实 Done操作是在 wg 的副本执行的。

因此 Wait 就死锁了。

这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。 这
个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面
的 wg 变量

```
在Go 1.7 以后引进的强大的Context上下文，实现并发控制
```
通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下
channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个
goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要
一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上
下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，
都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。

```
func main(){
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Printf("i:%d", i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```
```
i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!
```
```
goroutine 1 [semacquire]:
sync.runtime_Semacquire(0xc000094018)
/home/keke/soft/go/src/runtime/sema.go:56 +0x39
sync.(*WaitGroup).Wait(0xc000094010)
/home/keke/soft/go/src/sync/waitgroup.go:130 +0x64
main.main()
/home/keke/go/Test/wait.go:17 +0xab
exit status 2
```

context 包的核心是 struct Context，接口声明如下：

Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个
取消信号

Err() 在Done() 之后，返回context 取消的原因。

Deadline() 设置该context cancel的时间点

Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，
所有 goroutine 都会接收到取消信号。

一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消
信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不
能取消父操作。

## JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？　

首先JSON 标准库对 nil slice 和 空 slice 的处理是不一致.

通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。

此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回
值。

empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：

```
// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
// Done returns a channel that is closed when this `Context` is canceled
// or times out.
Done() <-chan struct{}
```
```
// Err indicates why this Context was canceled, after the Done channel
// is closed.
Err() error
```
```
// Deadline returns the time when this Context will be canceled, if any.
Deadline() (deadline time.Time, ok bool)
```
```
// Value returns the value associated with key or nil if none.
Value(key interface{}) interface{}
}
```
```
var slice []int
slice[1] = 0
```

### 当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何

### 值。

总之，nil slice 和 empty slice是不同的东⻄,需要我们加以区分的.

## 协程，线程，进程的区别。

### 进程

### 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单

### 位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，

### 所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

### 线程

### 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不

### 拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其

### 他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进

### 程不够稳定容易丢失数据。

### 协程

### 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换

### 时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基

### 本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## 关于协程，下列说法正确的有？

### A. 协程和线程都可以实现程序的并发执行；

### B. 线程比协程更轻量级；

### C. 协程不存在死锁问题；

D. 通过 channel 来进行协程间的通信；

答案

```
A D
```
## 互斥锁，读写锁，死锁问题是怎么解决。

### 互斥锁

互斥锁就是互斥变量mutex，用来锁住临界区的.

条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打
开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。

```
slice := make([]int,0）
slice := []int{}
```

### 读写锁

### 通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低

### 我们的程序效率。读写锁可以解决这个问题。

### 注意：写独占，读共享，写锁优先级高

### 死锁

一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线
程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这
叫做死锁（Deadlock）。 另外一种情况是：若线程A获得了锁 1 ，线程B获得了锁 2 ，这时线程A调用lock试图获得
锁 2 ，结果是需要挂起等待线程B释放锁 2 ，而这时线程B也调用lock试图获得锁 1 ，结果是需要挂起等待线程A释放
锁 1 ，于是线程A和B都永远处于挂起状态了。

死锁产生的四个必要条件:

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系
    统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

a. 预防死锁

可以把资源一次性分配：（破坏请求和保持条件）

然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）

资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路
等待条件）

b. 避免死锁

预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性
能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安
全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避
免死锁算法是银行家算法。

c. 检测死锁

首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.

d. 解除死锁

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有.

e. 剥夺资源


### 从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.

f. 撤消进程

可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先
级、运行代价、进程的重要性和价值等。

## Golang的内存模型，为什么小对象多了会造成gc压力。

### 通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.

## 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁?

Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁.

```
互斥锁
```
Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示。

sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock。

### 声明一个互斥锁：

```
//Mutex 是互斥锁， 零值是解锁的互斥锁， 首次使用后不得复制互斥锁。
type Mutex struct {
state int32
sema uint32
}
```
```
//Locker表示可以锁定和解锁的对象。
type Locker interface {
Lock()
Unlock()
}
```
```
//锁定当前的互斥量
//如果锁已被使用，则调用goroutine
//阻塞直到互斥锁可用。
func (m *Mutex) Lock()
```
```
//对当前互斥量进行解锁
//如果在进入解锁时未锁定m，则为运行时错误。
//锁定的互斥锁与特定的goroutine无关。
//允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。
func (m *Mutex) Unlock()
```
```
var mutex sync.Mutex
```

不像C或Java的锁类工具，我们可能会犯一个错误：忘记及时解开已被锁住的锁，从而导致流程异常。但Go由于存
在defer，所以此类问题出现的概率极低。关于defer解锁的方式如下：

### 如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态.

我们在for循环之前开始加锁，然后在每一次循环中创建一个协程，并对其加锁，但是由于之前已经加锁了，所以
这个for循环中的加锁会陷入阻塞直到main中的锁被解锁， time.Sleep(time.Second) 是为了能让系统有足够的时
间运行for循环，输出结果如下：

```
var mutex sync.Mutex
func Write() {
mutex.Lock()
defer mutex.Unlock()
}
```
```
fpackage main
```
```
import (
"fmt"
"sync"
"time"
)
```
```
func main() {
```
```
var mutex sync.Mutex
fmt.Println("begin lock")
mutex.Lock()
fmt.Println("get locked")
for i := 1; i <= 3; i++ {
go func(i int) {
fmt.Println("begin lock ", i)
mutex.Lock()
fmt.Println("get locked ", i)
}(i)
}
```
```
time.Sleep(time.Second)
fmt.Println("Unlock the lock")
mutex.Unlock()
fmt.Println("get unlocked")
time.Sleep(time.Second)
}
```

### 这里可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程 3 获胜。

互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个
未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer。

我们知道如果遇到panic，可以使用recover方法进行恢复，但是如果对重复解锁互斥锁引发的panic却是无用的
（Go 1.8及以后）。

### 运行:

```
> go run mutex.go
begin lock
get locked
begin lock 3
begin lock 1
begin lock 2
Unlock the lock
get unlocked
get locked 3
```
```
package main
```
```
import (
"fmt"
"sync"
)
```
```
func main() {
defer func() {
fmt.Println("Try to recover the panic")
if p := recover(); p != nil {
fmt.Println("recover the panic : ", p)
}
}()
var mutex sync.Mutex
fmt.Println("begin lock")
mutex.Lock()
fmt.Println("get locked")
fmt.Println("unlock lock")
mutex.Unlock()
fmt.Println("lock is unlocked")
fmt.Println("unlock lock again")
mutex.Unlock()
}
```
```
> go run mutex.go
begin lock
get locked
unlock lock
```

这里试图对重复解锁引发的panic进行recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是
建议将对同一个互斥锁的加锁解锁操作放在同一个层次的代码中。

```
读写锁
```
读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。

读写锁的访问控制规则如下：

① 多个写操作之间是互斥的 ② 写操作与读操作之间也是互斥的 ③ 多个读操作之间不是互斥的

在这样的控制规则下，读写锁可以大大降低性能损耗。

在Go的标准库代码包中sync中的RWMutex结构体表示为:

```
lock is unlocked
unlock lock again
fatal error: sync: unlock of unlocked mutex
```
```
goroutine 1 [running]:
runtime.throw(0x4bc1a8, 0x1e)
/home/keke/soft/go/src/runtime/panic.go:617 +0x72 fp=0xc000084ea8
sp=0xc000084e78 pc=0x427ba2
sync.throw(0x4bc1a8, 0x1e)
/home/keke/soft/go/src/runtime/panic.go:603 +0x35 fp=0xc000084ec8
sp=0xc000084ea8 pc=0x427b25
sync.(*Mutex).Unlock(0xc00001a0c8)
/home/keke/soft/go/src/sync/mutex.go:184 +0xc1 fp=0xc000084ef0 sp=0xc000084ec8
pc=0x45f821
main.main()
/home/keke/go/Test/mutex.go:25 +0x25f fp=0xc000084f98 sp=0xc000084ef0
pc=0x486c1f
runtime.main()
/home/keke/soft/go/src/runtime/proc.go:200 +0x20c fp=0xc000084fe0
sp=0xc000084f98 pc=0x4294ec
runtime.goexit()
/home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc000084fe8
sp=0xc000084fe0 pc=0x450ad1
exit status 2
```

sync中的RWMutex有以下几种方法：

Unlock方法会试图唤醒所有想进行读锁定而被阻塞的协程，而 RUnlock方法只会在已无任何读锁定的情况下，试图
唤醒一个因欲进行写锁定而被阻塞的协程。若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的
panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。

由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个
读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作。

```
// RWMutex是一个读/写互斥锁，可以由任意数量的读操作或单个写操作持有。
// RWMutex的零值是未锁定的互斥锁。
//首次使用后，不得复制RWMutex。
//如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，
goroutine不应该期望能够获取读锁定。
//特别是，这种禁止递归读锁定。 这是为了确保锁最终变得可用; 阻止的锁定会阻止新读操作获取锁定。
type RWMutex struct {
w Mutex //如果有待处理的写操作就持有
writerSem uint32 // 写操作等待读操作完成的信号量
readerSem uint32 //读操作等待写操作完成的信号量
readerCount int32 // 待处理的读操作数量
readerWait int32 // number of departing readers
}
```
### //对读操作的锁定

```
func (rw *RWMutex) RLock()
//对读操作的解锁
func (rw *RWMutex) RUnlock()
//对写操作的锁定
func (rw *RWMutex) Lock()
//对写操作的解锁
func (rw *RWMutex) Unlock()
```
```
//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.
func (rw *RWMutex) RLocker() Locker
```
```
package main
```
```
import (
"fmt"
"sync"
"time"
)
```
```
func main() {
var rwm sync.RWMutex
for i := 0; i < 5; i++ {
go func(i int) {
fmt.Println("try to lock read ", i)
```

### 运行:

这里可以看到创建了五个协程用于对读写锁的读锁定与读解锁操作。在 rwm.Lock()种会对main中协程进行写锁
定，但是for循环中的读解锁尚未完成，因此会造成mian中的协程阻塞。当for循环中的读解锁操作都完成后就会试
图唤醒main中阻塞的协程，main中的写锁定才会完成。

```
sync.Map安全锁
```
golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体。

应用示例:

```
rwm.RLock()
fmt.Println("get locked ", i)
time.Sleep(time.Second * 2)
fmt.Println("try to unlock for reading ", i)
rwm.RUnlock()
fmt.Println("unlocked for reading ", i)
}(i)
}
time.Sleep(time.Millisecond * 1000)
fmt.Println("try to lock for writing")
rwm.Lock()
fmt.Println("locked for writing")
}
```
```
> go run rwmutex.go
try to lock read 0
get locked 0
try to lock read 4
get locked 4
try to lock read 3
get locked 3
try to lock read 1
get locked 1
try to lock read 2
get locked 2
try to lock for writing
try to unlock for reading 0
unlocked for reading 0
try to unlock for reading 2
unlocked for reading 2
try to unlock for reading 1
unlocked for reading 1
try to unlock for reading 3
unlocked for reading 3
try to unlock for reading 4
unlocked for reading 4
locked for writing
```

### 运行 :

sync.Map的数据结构:

```
package main
import (
"sync"
"fmt"
)
```
```
func main() {
//开箱即用
var sm sync.Map
//store 方法,添加元素
sm.Store(1,"a")
//Load 方法，获得value
if v,ok:=sm.Load(1);ok{
fmt.Println(v)
}
//LoadOrStore方法，获取或者保存
//参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则
store，返回该value 和false
if vv,ok:=sm.LoadOrStore(1,"c");ok{
fmt.Println(vv)
}
if vv,ok:=sm.LoadOrStore(2,"c");!ok{
fmt.Println(vv)
}
//遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false
时，遍历立刻结束。
sm.Range(func(k,v interface{})bool{
fmt.Print(k)
fmt.Print(":")
fmt.Print(v)
fmt.Println()
return true
})
}
```
```
a
a
c
1:a
2:c
```

read的数据结构是：

entry的数据结构：

Delete 方法:

```
type Map struct {
// 该锁用来保护dirty
mu Mutex
// 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的
read atomic.Value // readOnly
//包含最新的写入的数据，并且在写的时候，会把read 中未被删除的数据拷⻉到该dirty中，因为是普通的map
存在并发安全问题，需要用到上面的mu字段。
dirty map[interface{}]*entry
// 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷⻉到read中（从而提升
读的性能）。
misses int
}
```
```
type readOnly struct {
m map[interface{}]*entry
// 如果Map.dirty的数据和m 中的数据不一样是为true
amended bool
}
```
```
type entry struct {
//可⻅value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存
储的空间应该不是问题
p unsafe.Pointer // *interface{}
}
```
```
func (m *Map) Delete(key interface{}) {
read, _ := m.read.Load().(readOnly)
e, ok := read.m[key]
//如果read中没有，并且dirty中有新元素，那么就去dirty中去找
if !ok && read.amended {
m.mu.Lock()
//这是双检查（上面的if判断和锁不是一个原子性操作）
read, _ = m.read.Load().(readOnly)
e, ok = read.m[key]
if !ok && read.amended {
//直接删除
delete(m.dirty, key)
}
m.mu.Unlock()
}
if ok {
```

Store 方法:

```
//如果read中存在该key，则将该value 赋值nil（采用标记的方式删除！）
e.delete()
}
}
```
```
func (e *entry) delete() (hadValue bool) {
for {
p := atomic.LoadPointer(&e.p)
if p == nil || p == expunged {
return false
}
if atomic.CompareAndSwapPointer(&e.p, p, nil) {
return true
}
}
}
```
```
func (m *Map) Store(key, value interface{}) {
// 如果m.read存在这个key，并且没有被标记删除，则尝试更新。
read, _ := m.read.Load().(readOnly)
if e, ok := read.m[key]; ok && e.tryStore(&value) {
return
}
// 如果read不存在或者已经被标记删除
m.mu.Lock()
read, _ = m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
//如果entry被标记expunge，则表明dirty没有key，可添加入dirty，并更新entry
if e.unexpungeLocked() {
//加入dirty中
m.dirty[key] = e
}
//更新value值
e.storeLocked(&value)
//dirty 存在该key，更新
} else if e, ok := m.dirty[key]; ok {
e.storeLocked(&value)
//read 和dirty都没有，新添加一条
} else {
//dirty中没有新的数据，往dirty中增加第一个新键
if !read.amended {
//将read中未删除的数据加入到dirty中
m.dirtyLocked()
m.read.Store(readOnly{m: read.m, amended: true})
}
m.dirty[key] = newEntry(value)
}
```

m.mu.Unlock()
}

//将read中未删除的数据加入到dirty中
func (m *Map) dirtyLocked() {
if m.dirty != nil {
return
}
read, _ := m.read.Load().(readOnly)
m.dirty = make(map[interface{}]*entry, len(read.m))
//read如果较大的话，可能影响性能
for k, e := range read.m {
//通过此次操作，dirty中的元素都是未被删除的，可⻅expunge的元素不在dirty中
if !e.tryExpungeLocked() {
m.dirty[k] = e
}
}
}

//判断entry是否被标记删除，并且将标记为nil的entry更新标记为expunge
func (e *entry) tryExpungeLocked() (isExpunged bool) {
p := atomic.LoadPointer(&e.p)
for p == nil {
// 将已经删除标记为nil的数据标记为expunged
if atomic.CompareAndSwapPointer(&e.p, nil, expunged) {
return true
}
p = atomic.LoadPointer(&e.p)
}
return p == expunged
}

//对entry 尝试更新
func (e *entry) tryStore(i *interface{}) bool {
p := atomic.LoadPointer(&e.p)
if p == expunged {
return false
}
for {
if atomic.CompareAndSwapPointer(&e.p, p, unsafe.Pointer(i)) {
return true
}
p = atomic.LoadPointer(&e.p)
if p == expunged {
return false
}
}
}


因此，每次操作先检查read，因为read 并发安全，性能好些；read不满足，则加锁检查dirty，一旦是新的键值，
dirty会被read更新。

Load方法:

Load方法是一个加载方法，查找key。

```
//read里 将标记为expunge的更新为nil
func (e *entry) unexpungeLocked() (wasExpunged bool) {
return atomic.CompareAndSwapPointer(&e.p, expunged, nil)
}
```
```
//更新entry
func (e *entry) storeLocked(i *interface{}) {
atomic.StorePointer(&e.p, unsafe.Pointer(i))
}
```
```
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
//因read只读，线程安全，先查看是否满足条件
read, _ := m.read.Load().(readOnly)
e, ok := read.m[key]
//如果read没有，并且dirty有新数据，那从dirty中查找，由于dirty是普通map，线程不安全，这个时候用
到互斥锁了
if !ok && read.amended {
m.mu.Lock()
// 双重检查
read, _ = m.read.Load().(readOnly)
e, ok = read.m[key]
// 如果read中还是不存在，并且dirty中有新数据
if !ok && read.amended {
e, ok = m.dirty[key]
// mssLocked（）函数是性能是sync.Map 性能得以保证的重要函数，目的讲有锁的dirty数据，
替换到只读线程安全的read里
m.missLocked()
}
m.mu.Unlock()
}
if !ok {
return nil, false
}
return e.load()
}
```
```
//dirty 提升至read 关键函数，当misses 经过多次因为load之后，大小等于len（dirty）时候，讲dirty替换
到read里，以此达到性能提升。
func (m *Map) missLocked() {
m.misses++
if m.misses < len(m.dirty) {
return
}
```

sync.Map是通过冗余的两个数据结构(read、dirty),实现性能的提升。为了提升性能，load、delete、store等操作
尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，
采用延迟标记删除法，只有在提升dirty的时候才删除。

## 什么是channel，为什么它可以做到线程安全？

Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯
(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。

Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:
不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计
Channel的主要目的就是在多任务间传递数据的，这当然是安全的。

## 读写锁或者互斥锁读的时候能写吗?

Go中读写锁包括读锁和写锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才
能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可
以同时读，但是读-写，写-写都是互斥的。

## 怎么限制Goroutine的数量.

在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或
者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量,这样就需要在每一次执行go之前判断
goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道
写入值，直到通道满的时候就阻塞了，

### //原子操作，耗时很小

```
m.read.Store(readOnly{m: m.dirty})
m.dirty = nil
m.misses = 0
}
```
```
package main
```
```
import "fmt"
```
```
var ch chan int
```
```
func elegance(){
<-ch
fmt.Println("the ch value receive",ch)
}
```
```
func main(){
ch = make(chan int,5)
for i:=0;i<10;i++{
```

### 运行:

```
ch <-1
fmt.Println("the ch value send",ch)
go elegance()
fmt.Println("the result i",i)
}
```
```
}
```
```
> go run goroutine.go
the ch value send 0xc00009c000
the result i 0
the ch value send 0xc00009c000
the result i 1
the ch value send 0xc00009c000
the result i 2
the ch value send 0xc00009c000
the result i 3
the ch value send 0xc00009c000
the result i 4
the ch value send 0xc00009c000
the result i 5
the ch value send 0xc00009c000
the ch value receive 0xc00009c000
the result i 6
the ch value receive 0xc00009c000
the ch value send 0xc00009c000
the result i 7
the ch value send 0xc00009c000
the result i 8
the ch value send 0xc00009c000
the result i 9
the ch value send 0xc00009c000
the ch value receive 0xc00009c000
the ch value receive 0xc00009c000
the ch value receive 0xc00009c000
the result i 10
the ch value send 0xc00009c000
the result i 11
the ch value send 0xc00009c000
the result i 12
the ch value send 0xc00009c000
the result i 13
the ch value send 0xc00009c000
the ch value receive 0xc00009c000
the ch value receive 0xc00009c000
the ch value receive 0xc00009c000
the ch value receive 0xc00009c000
```

这样每次同时运行的goroutine就被限制为 5 个了。但是新的问题于是就出现了，因为并不是所有的goroutine都执
行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到
sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。

```
the result i 14
the ch value receive 0xc00009c000
> go run goroutine.go
the ch value send 0xc00007e000
the result i 0
the ch value send 0xc00007e000
the result i 1
the ch value send 0xc00007e000
the result i 2
the ch value send 0xc00007e000
the result i 3
the ch value send 0xc00007e000
the ch value receive 0xc00007e000
the result i 4
the ch value send 0xc00007e000
the ch value receive 0xc00007e000
the result i 5
the ch value send 0xc00007e000
the ch value receive 0xc00007e000
the result i 6
the ch value send 0xc00007e000
the result i 7
the ch value send 0xc00007e000
the ch value receive 0xc00007e000
the ch value receive 0xc00007e000
the ch value receive 0xc00007e000
the result i 8
the ch value send 0xc00007e000
the result i 9
```
```
package main
```
```
import (
"fmt"
"runtime"
"sync"
"time"
)
// Pool Goroutine Pool
type Pool struct {
queue chan int
wg *sync.WaitGroup
}
// New 新建一个协程池
func NewPool(size int) *Pool{
```

### 运行:

```
if size <=0{
size = 1
}
return &Pool{
queue:make(chan int,size),
wg:&sync.WaitGroup{},
}
}
// Add 新增一个执行
func (p *Pool)Add(delta int){
// delta为正数就添加
for i :=0;i<delta;i++{
p.queue <-1
}
// delta为负数就减少
for i:=0;i>delta;i--{
<-p.queue
}
p.wg.Add(delta)
}
// Done 执行完成减一
func (p *Pool) Done(){
<-p.queue
p.wg.Done()
}
// Wait 等待Goroutine执行完毕
func (p *Pool) Wait(){
p.wg.Wait()
}
```
```
func main(){
// 这里限制 5 个并发
pool := NewPool(5)
fmt.Println("the NumGoroutine begin is:",runtime.NumGoroutine())
for i:=0;i<20;i++{
pool.Add(1)
go func(i int) {
time.Sleep(time.Second)
fmt.Println("the NumGoroutine continue is:",runtime.NumGoroutine())
pool.Done()
}(i)
}
pool.Wait()
fmt.Println("the NumGoroutine done is:",runtime.NumGoroutine())
}
```
```
the NumGoroutine begin is: 1
```

其中，Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU,最
大程度的提高我们程序的并发性能。runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的
Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做
是活跃的或者说正在被调度。

这里需要注意下：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。

## Channel是同步的还是异步的.

Channel是异步进行的。

channel存在 3 种状态：

```
nil，未初始化的状态，只进行了声明，或者手动赋值为nil
active，正常的channel，可读或者可写
closed，已关闭，千万不要误认为关闭channel后，channel的值是nil
```
## 下列哪个类型可以使用 cap()函数？

A. array

B. slice

C. map

D. channel

答案

```
the NumGoroutine continue is: 6
the NumGoroutine continue is: 7
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 6
the NumGoroutine continue is: 3
the NumGoroutine continue is: 2
the NumGoroutine done is: 1
```

### A B D

```
array 返回数组的元素个数；
slice 返回 slice 的最大容量；
channel 返回 channel 的容量；
```
## Data Race问题怎么解决？能不能不加锁解决这个问题？

同步访问共享数据是处理数据竞争的一种有效的方法.golang在1.1之后引入了竞争检测机制，可以使用 go run -
race 或者 go build -race来进行静态检测。 其在内部的实现是,开启多个协程执行同一个命令， 并且记录下每个变
量的状态.

竞争检测器基于C/C++的ThreadSanitizer 运行时库，该库在Google内部代码基地和Chromium找到许多错误。这
个技术在 2012 年九月集成到Go中，从那时开始，它已经在标准库中检测到 42 个竞争条件。现在，它已经是我们持
续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。

竞争检测器已经完全集成到Go工具链中，仅仅添加-race标志到命令行就使用了检测器。

要想解决数据竞争的问题可以使用互斥锁sync.Mutex,解决数据竞争(Data race),也可以使用管道解决,使用管道的效
率要比互斥锁高.

## 如何在运行时检查变量类型？

类型开关是在运行时检查变量类型的最佳方式。类型开关按类型而不是值来评估变量。每个 Switch 至少包含一个
case，用作条件语句，和一个 defaultcase，如果没有一个 case 为真，则执行。

## Go 两个接口之间可以存在什么关系？

### 如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A的方法列表是接口 B的方法列

### 表的自己，那么接口 B可以赋值给接口 A。接口查询是否成功，要在运行期才能够确定。

## 关于map，下面说法正确的是？

A. map 反序列化时 json.unmarshal() 的入参必须为 map 的地址；

B. 在函数调用中传递 map，则子函数中对 map 元素的增加不会导致父函数中 map 的修改；

C. 在函数调用中传递 map，则子函数中对 map 元素的修改不会导致父函数中 map 的修改；

D. 不能使用内置函数 delete() 删除 map 的元素

答案

```
$ go test -race mypkg // 测试包
$ go run -race mysrc.go // 编译和运行程序
$ go build -race mycmd // 构建程序
$ go install -race mypkg // 安装程序
```

### A

## 关于同步锁，下面说法正确的是？

A. 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖的等待，除非该 goroutine 释放这个 Mutex；

B. RWMutex 在读锁占用的情况下，会阻止写，但不阻止读；

C. RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine
独占；

D. Lock() 操作需要保证有 Unlock() 或 RUnlock() 调用与之对应；

答案

```
A B C , 106
```
## Go 当中同步锁有什么特点？作用是什么

当一个 Goroutine（协程）获得了 Mutex 后，其他 Gorouline（协程）就只能乖乖的等待，除非该 gorouline 释
放了该 MutexRWMutex在读锁占用的情况下，会阻止写，但不阻止读 RWMutex 在写锁占用情况下，会阻止任何
其他

goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占同步锁的作用是保证资源在使用时的独有性，
不会因为并发而导致数据错乱，保证系统的稳定性。

## Go 语言当中 Channel（通道）有什么特点，需要注意什么？

如果给一个 nil 的 channel 发送数据，会造成永远阻塞如果从一个 nil 的 channel 中接收数据，也会造成永久爱阻
塞给一个已经关闭的 channel 发送数据，会引起 pannic 从一个已经关闭的 channel 接收数据，如果缓冲区中为
空，则返回一个零值。

## Go 语言当中 Channel 缓冲有什么特点？

无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。

## 关于channel，下面语法正确的是?

A. var ch chan int

B. ch := make(chan int)

C. <- ch

D. ch <-

答案

```
ABC
```

```
写 chan 时，<- 右端必须要有值
```
## Go 语言中 cap 函数可以作用于那些内容？

cap 函数在讲引用的问题中已经提到，可以作用于的类型有：

```
array(数组)
slice(切片)
channel(通道)
```
## go convey 是什么？一般用来做什么？

```
go convey 是一个支持 golang 的单元测试框架
go convey 能够自动监控文件修改并启动测试，并可以将测试结果实时输出到 Web界面
go convey 提供了丰富的断言简化测试用例的编写
```
## Go 语言当中 new 和 make 有什么区别吗？

new的作用是初始化一个纸箱类型的指针 new函数是内建函数，函数定义：

```
使用 new函数来分配空间
传递给 new函数的是一个类型，而不是一个值
返回值是指向这个新非配的地址的指针
```
## Go 语言中 make 的作用是什么？

make的作用是为 slice, map or chan 的初始化然后返回引用 make函数是内建函数，函数定义：

make(T, args)函数的目的和 new(T)不同仅仅用于创建 slice, map, channel 而且返回类型是实例。

## Printf(),Sprintf(),FprintF()都是格式化输出，有什么不同？

虽然这三个函数，都是格式化输出，但是输出的目标不一样 Printf 是标准输出，一般是屏幕，也可以重定向。
Sprintf()是把格式化字符串输出到指定的字符串中。 Fprintf()是吧格式化字符串输出到文件中。

## Go 语言当中数组和切片的区别是什么？

数组：数组固定⻓度数组⻓度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组类型数组需要指定大
小，不指定也会根据处初始化对的自动推算出大小，不可改变数组是通过值传递的

切片：切片可以改变⻓度切片是轻量级的数据结构，三个属性，指针，⻓度，容量不需要指定大小切片是地址传递
（引用传递）可以通过数组来初始化，也可以通过内置函数 make()来初始化，初始化的时候 len=cap，然后进行
扩容。

```
func new(Type)*Type
```
```
func make(Type, size IntegerType) Type
```

## Go 语言当中值传递和地址传递（引用传递）如何运用？有什么区别？举例

## 说明

### 1. 值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。

### 2. 地址传递(引用传递)会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。

## Go 语言当中数组和切片在传递的时候的区别是什么？

### 1. 数组是值传递

### 2. 切片是引用传递

## Go 语言是如何实现切片扩容的？

### 我们可以看下结果

### 依次是0,1,2,4,8,16,32,64,128,256,512,1024 但到了 1024 之后,就变成了1024,1280,1696,2304 每次都是扩容了四

### 分之一左右

## 关于 channel 下面描述正确的是？

A. 向已关闭的通道发送数据会引发 panic；

B. 从已关闭的缓冲通道接收数据，返回已缓冲数据或者零值；

C. 无论接收还是接收，nil 通道都会阻塞；

D. close() 可以用于只接收通道；

E. 单向通道可以转换为双向通道；

F. 不能在单向通道上做逆向操作（例如：只发送通道用于接收）；

答案

```
A B C F
```
```
func main(){
arr := make([]int, 0 )
```
```
for i := 0 ; i < 2000 ; i++{
```
```
fmt.Println("len 为", len(arr),"cap 为", cap(arr)) arr = append(arr, i)
}
}
```

## 看下面代码的 defer 的执行顺序是什么？ defer 的作用和特点是什么？

defer 的作用是：

你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法。当 defer 语句被执行时，跟
在 defer 后面的函数会被延迟执行。直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论
包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条
defer 语句，它们的执行顺序与声明顺序相反。

defer 的常用场景：

```
defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。
通过 defer 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。
释放资源的 defer 应该直接跟在请求资源的语句后。
```
## Golang Slice 的底层实现

### 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对 底层数组的抽象 。因为基于数组实

### 现，所以它的底层的 内存是连续分配 的，效率非常高，还可以通过 索引 获得数据，可以 迭代以及垃圾回收优化 。切

### 片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用

### 底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指

### 针的一种封装。切片对象非常小，是因为它是只有 3 个字段的数据结构：

### 指向底层数组的指针

### 切片的⻓度

### 切片的容量

## Golang Slice 的扩容机制，有什么注意点？

Go 中切片扩容的策略是这样的：

```
首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容量
否则判断，如果旧切片的⻓度小于 1024 ，则最终容量就是旧容量的两倍
否则判断，如果旧切片⻓度大于等于 1024 ，则最终容量从旧容量开始循环增加原来的1/4,直到最终容量大于
等于新申请的容量
如果最终容量计算值溢出，则最终容量就是新申请容量
```
## 扩容前后的 Slice 是否相同？

### 情况一：原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，

对一个切片的操作可能影响多个指针指向相同地址的 Slice。

情况二：原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷⻉过来，然
后再执行 append()操作。这种情况丝毫不影响原数组。

要复制一个 Slice，最好使用 Copy函数。


## Golang 的参数传递、引用类型

Go 语言中 **所有的传参都是值传递** (传值)，都是一个副本，一个拷⻉。因为拷 ⻉的内容有时候是非引用类型(int、
string、struct 等这些)，这样就在函 数中就无法修改原内容数据;有的是 **引用类型** (指针、map、slice、chan等 这
些)，这样就可以修改原内容数据。

Golang 的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除 了申请内存外，还需要初始化相关
属性。内置函数 new 计算类型大小，为其分 配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函
数，由其分 配内存和初始化成员结构，返回对象而非指针。

## Golang Map 底层实现

Golang 中 map的底层实现是一个散列表，因此实现 map的过程实际上就是实现散表的过程。在这个散列表中，主
要出现的结构体有两个，一个叫 hmap(a header for a go map)，一个叫 bmap(a bucket for a Go map，通常叫
其bucket)。

## new() 与 make() 的区别

```
new只初始化并返回指针，而make不仅仅要做初始化，还需要设置一些数组的⻓度、容量等
```
## Golang Map 如何扩容

装载因子：count/2^B

触发条件：

1. 装填因子是否大于6.5
2. overflow bucket 是否太多

解决方法：

1. 双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个
    bucket
2. 等量扩容：重新排列，极端情况下，重新排列也解决不了，map成了链表，性能大大降低，此时哈希种子
    hash0 的设置，可以降低此类极端场景的发生。

## Golang Map 查找

Go语言中 map采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值， 64 位系统中就生成一个64bit 的哈希
值，由这个哈希值将 key 对应到不同的桶

```
bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。key 经过 hash 后共 64 位，根
据 hmap中 B的值，计算它到底要落在哪个桶时，桶的数量为2^B，如 B=5，那么用 64 位最后 5 位表示第几号
桶，在用 hash 值的高 8 位确定在 bucket 中的存储位置，当前 bmap中的 bucket 未找到，则查询对应的
overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。
```

如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历 bucket 中的 key 如果当前处于 map进
行了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。

## 介绍一下 Channel

Go语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go的 CSP(Communicating Sequential
Process)并发模型，中文可以叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。

所以 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小部位 0 时，
是个 ring buffer)、sendx 和 recvx 收发的位置(ring buffer 记录实现)、sendq、recvq 当前 channel 因为缓冲区不
足而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。

## Go 语言的 Channel 特性？

1. 给一个 nil channel 发送数据，造成永远阻塞
2. 从一个 nil channel 接收数据，造成永远阻塞
3. 给一个已经关闭的 channel 发送数据，引起 panic
4. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
5. 无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的
6. 关闭一个 nil channel 将会发生 panic

## Channel 的 ring buffer 实现

channel 中使用了 ring buffer(环形缓冲区)来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现
FIFO 式的固定⻓度队列。在 channel 中，ring buffer 的实现如下：

hchan 中有两个与 buffer 相关的变量:recvx 和 sendx。其中 sendx 表示buffer 中可写的 index，recvx 表示
buffer 中可读的 index。从 recvx 到 sendx 之间的元素，表示已正常存放入 buffer 中的数据。

我们可以直接使用 buf[recvx]来读取到队列的第一个元素，使用 buf[sendx]= x 来将元素放到队尾。
