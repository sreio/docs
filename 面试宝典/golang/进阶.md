## Go 进阶


### golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一

### 个case呢？

https://mp.weixin.qq.com/s/Oa3eExufo2Req_9IrDys-g

### golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？

https://mp.weixin.qq.com/s/izbZ3JRqX6jI6Wn7bV6xNQ

### golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？

https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A

### golang面试题：能说说uintptr和unsafe.Pointer的区别吗？

https://mp.weixin.qq.com/s/PSkz0zj-vqKzmIKa_b-xAA

### golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不

### 能导出私有变量的 tag？

https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg

### Golang GC 时会发生什么?

#### 首先我们先来了解下垃圾回收.什么是垃圾回收？

#### 内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心

#### 的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以

#### 定位，一直成为困扰程序开发者的噩梦。如何解决这个头疼的问题呢？

#### 过去一般采用两种办法：

#### 内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然

#### 而检测工具难免有疏漏和不足，只能起到辅助作用。

```
智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程
序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者
有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。
```

为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管
理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运
行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。

常用的垃圾回收的方法:

```
引用计数（reference counting）
```
这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象
的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动
加一。当引用计数为 0 时则立即回收对象。

这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比
较广泛，如ios cocoa框架，php，python等。

但是简单引用计数算法也有明显的缺点：

1. 频繁更新引用计数降低了性能。

一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时
变量引用不进行计数，而是在引用达到 0 时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很
多其他方法，具体可以参考这里。

1. 循环引用。

当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入
了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的
复杂度。

```
标记-清除（mark and sweep）
```
标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历
访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴
有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前
所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&sweep算法的变种（如三色标
记法）优化了这个问题。

```
分代搜集（generation）
```
java的jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基
本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young
generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较⻓的对
象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。

因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃
圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍
然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。

Golang GC 时会发生什么?

Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。

golang 中的 gc 基本上是标记清除的过程：


gc的过程一共分为四个阶段：

1. 栈扫描（开始时STW）
2. 第一次标记（并发）
3. 第二次标记（STW）
4. 清除（并发）

整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。

1. 先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的
    goroutine立即入队给调度器，进而被CPU处理
2. 第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列
3. 第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，
    这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到
    达的对象，即没有被引用的对象；
4. 第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏
    障）去记录

Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。

详细的Golang的GC介绍可以参看Golang垃圾回收.

### Golang 中 Goroutine 如何调度?

goroutine是Golang语言中最经典的设计，也是其魅力所在，goroutine的本质是协程，是实现并行计算的核心。
goroutine使用方式非常的简单，只需使用go关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等
它运行完成以后在执行以后的代码。

#### 协程:

```
go func()//通过go关键字启动一个协程来运行函数
```

#### 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢

#### 复先前保存的寄存器上下文和栈。 因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每

#### 次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。 线程和进程的

操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。

groutine能拥有强大的并发实现是通过GPM调度模型实现.

Go的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched未给出）.

```
M:M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护
小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息
G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调
度。
P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队
列，里面存储了所有需要它来执行的goroutine
Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。
```
调度实现:

从上图中可以看到，有 2 个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P
的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。


图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为
runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，
runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个
goroutine？）一个goroutine执行。

当一个OS线程M0陷入阻塞时，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。

当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来， 如
果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也
会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。

另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任
务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。


通常来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的
使用。

### 并发编程概念是什么？

#### 并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。

#### 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台

处理器上同时处理多个任务。如hadoop分布式集群

并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。

并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发
生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

### 下面这段代码有什么错误吗？

#### 解析

#### 第二个返回值没有命名,在函数有多个返回值时，只要有一个返回值有命名，

#### 其他的也必须命名。如果有多个返回值必须加上括号()；

#### 如果只有一个返回值且命名也必须加上括号()。

```
这里的第一个返回值有命名 sum，第二个没有命名，所以错误。
```
```
func funcMui(x,y int)(sum int,error){
return x+y,nil
}
```

### 下面几段代码能否通过编译，如果能，输出什么?

### 下面能否通过编译?

```
func main() {
list := new([]int)
// 编译错误
// new([]int) 之后的 list 是一个未设置⻓度的 *[]int 类型的指针
// 不能对未设置⻓度的指针执行 append 操作。
list = append(list, 1 )
fmt.Println(list)
```
```
s1 := []int{ 1 , 2 , 3 }
s2 := []int{ 4 , 5 }
// 编译错误，s2需要展开
s1 = append(s1, s2)
fmt.Println(s1)
}
```
```
func Test7(t *testing.T) {
sn1 := struct {
age int
name string
}{age: 11 , name: "qq"}
sn2 := struct {
age int
name string
}{age: 11 , name: "qq"}
// true
if sn1 == sn2 {
fmt.Println("sn1 == sn2")
}
```
```
sm1 := struct {
age int
m map[string]string
}{age: 11 , m: map[string]string{"a": "1"}}
sm2 := struct {
age int
m map[string]string
}{age: 11 , m: map[string]string{"a": "1"}}
// 编译错误，含有map、slice类型的struct不能进行比较
if sm1 == sm2 {
fmt.Println("sm1 == sm2")
}
}
```

### 通过指针变量 p 访问其成员变量 name，有哪几种方式？

A. p.name

B. (&p).name

C. (*p).name

D. p->name

答案

```
AC
```
### 关于字符串连接，下面语法正确的是？

A. str := 'abc' + '123'

B. str := "abc" + "123"

C. str := '123' + "abc"

D. fmt.Sprintf("abc%d", 123)

答案

```
BD
golang单引号''中的内容表示单个字符（rune）,反引号``中的内容表示不可转义的字符串
```
### 关于iota，下面代码输出什么?

#### 输出

```
0 2 pi pi 5 6
```
```
func Test10(t *testing.T) {
const (
x = iota
_
y
z = "pi"
k
p = iota
q
)
fmt.Println(x, y, z, k, p, q)
}
```

### Mutex 几种状态

```
mutexLocked —表示互斥锁的锁定状态；
mutexWoken —表示从正常模式被从唤醒；
mutexStarving —当前的互斥锁进入饥饿状态；
waitersCount —当前互斥锁上等待的 Goroutine 个数；
```
### Mutex 正常模式和饥饿模式

#### 正常模式(非公平锁)

正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会
和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU上执行，而且可能有好几
个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被

唤醒的 goroutine 会加入到等待队列的前面。如果一个等待的 goroutine 超过1ms没有获取锁，那么它将会把锁转
变为饥饿模式。

**饥饿模式(公平锁)**

为了解决了等待 G队列的⻓尾问题

饥饿模式下，直接由 unlock 把锁交给等待队列中排在第一位的 G(队头)，同时，饥饿模式下，新进来的 G不会参与
抢锁也不会进入自旋状态，会直接进入等待队列的尾部,这样很好的解决了老的 g 一直抢不到锁的场景。饥饿模式
的触发条件，当一个 G等待锁时间超过 1 毫秒时，或者当前队列只剩下一个 g 的时候，Mutex切换到饥饿模式。

**总结**

对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，
但是性能会下降，其实是性能和公平的一个平衡模式。

### Mutex 允许自旋的条件

#### 1 锁已被占用，并且锁不处于饥饿模式。

2 积累的自旋次数小于最大自旋次数（active_spin=4）。3 cpu 核数大于 1 。

4 有空闲的 P。

5 当前 goroutine 所挂载的 P下，本地待运行队列为空。

### RWMutex 实现

通过记录 readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数1<<30。目的是让
新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操
作。而等写锁释放完之后，会将值重新加上1<<30,并通知刚才新进入的读锁(rw.readerSem)，两者互相限制。


### RWMutex 注意事项

```
RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁
读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁
写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占
适用于读多写少的场景
RWMutex 类型变量的零值是一个未锁定状态的互斥锁。
RWMutex 在首次被使用之后就不能再被拷⻉。
RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic。
RWMutex 的一个写锁 Lock 去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这
个写锁操作的 goroutine 将被阻塞直到解锁。
RWMutex 的读锁不要用于递归调用，比较容易产生死锁。
RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个
goroutine 可以 RUnlock（Unlock）。
写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。
读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间
最⻓的一个 goroutine 会被唤醒。
```
### Cond 是什么

Cond实现了一种条件变量，可以使用在多个 Reader 等待共享资源 ready 的场景（如果只有一读一写，一个锁或
者 channel 就搞定了）

每个 Cond都会关联一个 Lock（sync.Mutex or sync.RWMutex），当修改条件或者调用 Wait 方法时，必须加
锁，保护 condition。

### Broadcast 和 Signal 区别

Broadcast 会唤醒所有等待 c 的 goroutine。调用 Broadcast 的时候，可以加锁，也可以不加锁。

Signal 只唤醒 1 个等待 c 的 goroutine。调用 Signal 的时候，可以加锁，也可以不加锁。

```
func (c *Cond) Broadcast()
```
```
func (c *Cond) Signal()
```

### Cond 中 Wait 使用

Wait()会自动释放 c.L，并挂起调用者的 goroutine。之后恢复执行，Wait()会在返回时对 c.L 加锁。

除非被 Signal 或者 Broadcast 唤醒，否则 Wait()不会返回。

由于 Wait()第一次恢复时，C.L 并没有加锁，所以当 Wait 返回时，调用者通常并不能假设条件为真。

取而代之的是,调用者应该在循环中调用 Wait。（简单来说，只要想使用 condition，就必须加锁。）

### WaitGroup 用法

一个 WaitGroup 对象可以等待一组协程结束。使用方法是：

1.main 协程通过调用 wg.Add(delta int)设置 worker 协程的个数，然后创建 worker 协程；

2.worker 协程执行结束以后，都要调用 wg.Done()；

3.main 协程调用 wg.Wait()且被 block，直到所有 worker 协程全部执行结束后返回。

### WaitGroup 实现原理

```
WaitGroup 主要维护了 2 个计数器，一个是请求计数器 v，一个是等待计数器 w，二者组成一个64bit 的值，
请求计数器占高32bit，等待计数器占低32bit。
每次 Add执行，请求计数器 v 加 1 ，Done方法执行，请求计数器减 1 ，v 为 0 时通过信号量唤醒 Wait()。
```
```
func (c *Cond) Wait()
```
```
c.L.Lock()
```
```
for !condition(){
```
```
c.Wait()
```
```
}
```
```
... make use of condition ...
```
```
c.L.Unlock()
```

### 下面代码输出什么？

A. compilation error

B. equal

C. not equal

答案

```
A 编译错误
```
```
对于数组而言，一个数组是由数组中的值和数组的⻓度两部分组成的，如果两个数组⻓度不同，那么两个数
组是属于
不同类型的，是不能进行比较的
```
### 什么是 sync.Once

```
Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。
Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测
试资源。
sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执
行，这里的 f 是一个无参数无返回值的函数。
```
### 什么操作叫做原子操作

一个或者多个操作在 CPU执行过程中不被中断的特性，称为原子性(atomicity)。这些操作对外表现成一个不可分割
的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU 不可能
不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可⻅，那我们就可以宣城他
们拥有了“不可分割”的原子性。

在 Go中，一条普通的赋值语句其实不是一个原子操作。列如，在 32 位机器上写 int64 类型的变量就会有中间状
态，因为他会被拆成两次写操作(MOV)——写低 32 位和写高 32 位。

```
func Test16(t *testing.T) {
a := [ 2 ]int{ 5 , 6 }
b := [ 3 ]int{ 5 , 6 }
if a == b {
fmt.Println("equal")
} else {
fmt.Println("not equal")
}
}
```

### 原子操作和锁的区别

#### 原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保

#### 护，原子操作通常会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用

atomic.Value 封装好的实现。

### 什么是 CAS

CAS的全称为 Compare And Swap，直译就是比较交换。是一条 CPU的原子指令，其作用是让 CPU先进行比较两
个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在 intel 的 CPU中，使用
的 cmpxchg指令，就是说 CAS是靠硬件实现的，从而在硬件层面提升效率。

简述过程是这样：

假设包含 3 个参数内存位置(V)、预期原值(A)和新值(B)。V表示要更新变量的值，E表示预期值，N表示新值。仅当 V
值等于 E值时，才会将 V的值设为 N，如果 V值和 E值不同，则说明已经有其他线程在做更新，则当前线程什么都
不

做，最后 CAS返回当前 V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于
这样的原理，CAS操作即使没有锁，也可以发现其他线程对于当前线程的干扰。

### sync.Pool 有什么用

对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一
定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直
接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。

### Goroutine 定义

Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多
个 goroutine 组成。它与线程、协程、进程等不同。它是一个 goroutine”—— Rob Pike

Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的通信和同步访问
控制。

### GMP 指的是什么

G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信
息.

M（Machine）：对内核级线程的封装，数量对应真实的 CPU数（真正干活的对象）.

P（Processor）：即为 G和 M的调度对象，用来调度 G和 M之间的关联关系，其数量可通过 GOMAXPROCS()来设
置，默认为核心数。


### 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题

https://mp.weixin.qq.com/s/-agtdhlW7Yj7S88a0z7KHg

### 你一定会遇到的内存回收策略导致的疑似内存泄漏的问题

https://colobu.com/2019/08/28/go-memory-leak-i-dont-think-so/

### GMP里为什么要有P?

https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA

### go栈扩容和栈缩容，连续栈的缺点

https://segmentfault.com/a/1190000019570427

### golang隐藏技能:怎么访问私有成员

https://www.jianshu.com/p/7b3638b47845

### 1.0 之前 GM 调度模型

#### 调度器把 G都分配到 M上，不同的 G在不同的 M并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源

是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从1.1 版本引入，在运行时系统的时候
加入 p 对象，让 P去管理这个 G对象，M想要运行 G，必须绑定 P，才能运行 P所管理

的 G。

1 ．单一全局互斥锁(Sched.Lock)和集中状态存储

2 ．Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine）

3 ．每个 M做内存缓存，导致内存占用过高，数据局部性较差

4 ．频繁 syscall 调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗。