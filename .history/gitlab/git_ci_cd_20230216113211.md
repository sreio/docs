> 转自[Gitlab-CICD最简单明了的入门教程](https://www.cnblogs.com/mrxccc/p/16504723.html)

## CICD是什么?

由于目前公司使用的gitlab，大部分项目使用的CICD是gitlab的CICD，少部分用的是jenkins，使用了gitlab-ci一段时间后感觉还不错，因此总结一下

介绍gitlab的CICD之前，可以先了解CICD是什么

我们的开发模式经历了如下的转变：瀑布模型->敏捷开发→DevOps(Development、Operations的组合词，是一组过程、方法与系统的统称)

后来随着DevOps的兴起，出现了持续集成（Continuous Integration）、持续交付（Continuous Delivery） 、持续部署（Continuous Deployment） 的新方法，关于持续集成、持续交付、持续部署，总结如下：

* `持续集成`的重点是将各个开发人员的工作集合到一个代码仓库中。通常，每天都要进行几次，主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。
* `持续交付`的目的是最小化部署或释放过程中固有的摩擦。它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。
* `持续部署`是一种更高程度的自动化，无论何时对代码进行重大更改，都会自动进行构建/部署。

### 持续集成的好处是什么？

持续集成可以使问题尽早暴露，从而也降低了解决问题的难度，正如老马所说，持续集成无法消除bug，但却能大大降低修复的难度和时间。

### 持续交付的好处是什么？

持续交付的好处在于快速获取用户反馈；适应市场变化和商业策略的变化。开发团队保证每次提交的修改都是可上线的修改，那么决定何时上线，上线哪部分功能则完全由产品业务团队决定。

虽然持续交付有显著的优点，但也有不成立的时候，比如对于嵌入式系统的开发，往往需要软硬件的配合。

### 持续部署的好处是什么？

持续部署的目标是通过减少批量工作的大小，并加快团队工作的节奏，帮助开发团队在其开发流程中消除浪费。这使团队能够一直处于一种可持续的平稳流状态， 让团队更容易去创新、试验，并达到可持续的生产率

市面上的CI有很多，如果在github上搜一下ci工具，也会搜到很多，比如：

- Travis CI
- Circle CI
- Jenkins
- AppVeyor
- CodeShip
- Drone
- Semaphore CI
- Buildkite
- Wercker
- TeamCity

这里只介绍Gitlab-CI

## Gitlab-CI

![1-1](./img/gitlab_logo.png)

* 项目页面：https://about.gitlab.com/product/continuous-integration/

* 源代码：https://gitlab.com/gitlab-org/gitlab-ce/

* 遵循 MIT 许可协议

GitLab 是 CI/CD 领域的一个新手玩家，但它已经在 Forrester Wave 持续集成工具中占据了领先地位。在这样一个竞争对手众多而水平又很高的领域，这是一项巨大的成就。是什么让 GitLab CI 如此了不起？

- 它使用 YAML 文件来描述整个管道。
- 它还有一个功能叫 Auto DevOps，使比较简单的项目可以自动构建内置了若干测试的管道。
- 使用 Herokuish 构建包来确定语言以及如何构建应用程序。有些语言还可以管理数据库，对于构建新的应用程序并在开发过程一开始就将其部署到生产环境中，这是一个很重要的功能。
- 提供到 Kubernetes 集群的原生集成，并使用多种部署方法的一种（如基于百分比的部署和蓝绿部署）将应用程序自动部署到 Kubernetes 集群中。

除了 CI 功能之外，GitLab 还提供了许多补充功能，比如自动把 Prometheus 和你的应用程序一起部署，实现运行监控；使用 GitLab 问题（Issues）、史诗（Epics）和里程碑（Milestones）进行项目组合和项目管理；管道内置了安全检查，提供跨多个项目的聚合结果；使用 WebIDE 在 GitLab 中编辑代码的能力，它甚至可以提供预览或执行管道的一部分，以获得更快的反馈。

### 相关概念

#### pipeline（管道、流水线）

- 一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程（`Stage`），比如自动构建、自动进行单元测试、自动进行代码检查等流程 ;
- 任何提交或者 Merge Request 的合并都可以触发 Pipeline ;

#### Stage（构建阶段）

- Stage表示构建阶段，就是上面提到的流程 ;
- 可以在一次 `Pipeline` 中定义多个 `Stage`;
- Stage有如下特点 :
    - 所有 stages 会按照顺序运行，即当一个 stage 完成后，下一个 Stage才会开始
    - 只有当所有 Stage 成功完成后，该构建任务 `Pipeline` 才算成功
    - 如果任何一个 Stage失败，那么后面的 Stage 不会执行，该构建任务 (Pipeline) 失败

阶段是对批量的作业的一个逻辑上的划分，每个 `pipeline` 都必须包含至少一个 `Stage`。多个 Stage是按照顺序执行的，如果其中任何一个 Stage失败，则后续的 Stage不会被执行，整个 CI 过程被认为失败。

#### Jobs（任务）

- job表示构建工作，表示某个stage里面执行的工作 ;
- 一个stage里面可以定义多个job ;
- jobs有如下特点 :
    - 相同 stage 中的jobs 会并行执行
    - 相同 stage 中的 jobs 都执行成功时，该 stage 才会成功
    - 如果任何一个job 失败，那么该 stage 失败，即该构建任务 (Pipeline) 失败

举一个例子，比如下面这个图：

![job-1](./img/job_1.png)

这里的四个Statge(阶段): `Verify`、`Build`、`Dockerpush`、`Deploy`四个，这四个阶段组成一条`Pipeline`

每个阶段都有一个job，所以总共四个job，也就是`unit-test`、`java-package`、`docker-push`、`service-1`这四个，当然，每个stage可以由多个job组成，比如下面这个图：

Job 的执行过程中往往会产生一些数据，默认情况下 GitLab Runner 会保存 Job 生成的这些数据，然后在下一个 Job 执行之前（甚至不局限于当次 CI/CD）将这些数据恢复。这样即便是不同的 Job 运行在不同的 Runner 上，它也能看到彼此生成的数据。

`.gitlab-ci.yml`中提供了 before_script 和 after_script 两个全局配置项。这两个配置项在所有 Job 的 script 执行前和执行后调用。

> 关于.gitlab-ci.yml、before_script、after_script是什么，先别急，在后面有介绍

在了解了 Job 配置的 script、before_script、after_script 和 cache 以后，可以将整个 Job 的执行流程用一张图概括：

![job-2](./img/job_2.png)

所以了解了Pipeline、Stage、Jobs后，还有一个很重要的东西，就是`Runner`

#### Runner

Runner就像一个个的工人，而Gitlab-CI就是这些工人的一个管理中心，所有工人都要在Gitlab-CI里面登记注册，并且表明自己是为哪个工程服务的。当相应的工程发生变化时，Gitlab-CI就会通知相应的工人执行软件集成脚本。如下图所示：

![runner-1](./img/runner_1.png)

gitlab里面的runner叫`Gitlab-Runner`，Gitlab-Runner是配合Gitlab-CI进行使用的。一般地，Gitlab里面的每一个工程都会定义一个属于这个工程的软件集成脚本，用来自动化地完成一些软件集成工作。当这个工程的仓库代码发生变动时，比如有人push了代码，GitLab就会将这个变动通知Gitlab-CI。这时Gitlab-CI会找出与这个工程相关联的Runner，并通知这些Runner把代码更新到本地并执行预定义好的执行脚本(也就是在`Job执行流程`那个图中所示的第三步：script)，所以，Gitlab-Runner就是一个用来执行软件集成脚本`script`的东西。

Runner类型

Gitlab-Runner可以分类两种类型：**Shared Runner（共享型) ** 和 **Specific Runner（指定型）**。

- Shared Runner：这种Runner（工人）是所有工程都能够用的。只有系统管理员能够创建Shared Runner。
- Specific Runner：这种Runner（工人）只能为指定的工程服务。拥有该工程访问权限的人都能够为该工程创建Shared Runner。

关于Gitlab-runner的安装，会以单独一个文章进行介绍，注册runner会对应一个tag，记住这个tag；